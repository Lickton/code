# Chap 1 构造过程抽象

## 1.1 程序设计的基本元素

+ 基本表达形式
+ 组合的方法
+ 抽象的方法

### 1.1.1 表达式

- 组合式：`(+ 99 20)`、`(* 1 2 3 4 5)`

- 运算符

- 运算对象

- 实际参数

- 前缀表示

- 嵌套：允许组合式的元素本身又是组合式

  ​			`(+ (- 100 1) 200)`

### 1.1.2 命名和环境

+ 变量、定义（最简单的抽象方法）：`(define size 2)`

  `define`不是一种组合式

  > 一个程序通常是由一大批相对简单的过程组成的。

+ 环境：解释器维护并保持有关名-值对偶的轨迹的储存环境

  > 环境所扮演的角色就是用于确定表达式中各个符号的意义

### 1.1.3 组合式的求值

+ 求值一个组合式的标准流程：

  1. 求值该组合式的各个子表达式
  2. 将作为最左子表达式（运算符）的值的那个过程应用于相应的实际参数（也就是其他子表达式的值）

  > 性质上，这一求值过程是递归的
  >
  > 采用递归的思想可以简洁的描述深度嵌套的情况

+ 递归视作一种处理层次性结构的强有力的技术

+ 树状积累

+ 求值规则：

  1. 数的值就是它们所表示的数值
  2. 内部运算符的值就是能够完成相应操作的机器指令序列
  3. 其他名字的值就是在环境中关联于这一名字的那个对象

### 1.1.4 复合过程

程序设计语言里的基本元素：

+ 数和算数运算是基本的数据和过程
+ 组合式的嵌套提供了一种组织起多个操作的方法
+ 定义是一种受限的抽象手段，它为名字关联相应的值

+ 过程定义：为复合操作提供名字

  `(define (square x) (* x x))`

  `(define (<name> <formal parameters>) <body>)`

### 1.1.5 过程应用的代换模型

+ 代换模型
+ 应用序与正则序
  + 正则序求值：先展开过程，再求值
  + 应用序求值：先求值，再代入过程

### 1.1.6 条件表达式和谓词

+ 分情况分析

  表达式的一般形式：

  ```lisp
  (cond (<p1> <e1>)
      (<p2> <e2>)
      ...
      (<pn> <en>))
  ```

  ```lisp
  (define (abs x)
      (cond ((> x 0) x)
         	 ((= x 0) 0)
         	 ((< x 0) (- x))))
  ```

+ 谓语：每个对偶的第一个表达式

+ 谓词：返回真或假的过程，也指能求出真或假的表达式

  ```lisp
  (define (abs x)
      (cond ((< x) (- x))
          (else x)))
  ```

  + `if`表达式的一般形式为:`(if <predicate> <consequent> <alternative>)`

  ```lisp
  (define (abs x)
      (if (< x 0)
          (- x)
          x))
  ```

  + `and`、`or`：都是特殊形式而非普通的过程，因为它们的子表达式不一定都求值，比如说`(or 1 abs(0))`当中`abs(0)`就没有求值

### 练习

+ 1.2

  ```lisp
  (/ (+ 5
        4
        (- 2 
           (- 3 
              (+ 6
                 (/ 4 5)))))
     (* 3
        (- 6
           2)
        (- 2
           7)))
  ```

+ 1.3

  ```lisp
  (define (f x y z)
      (cond ((> x y) (if (> x z) 
                         x))
          ((> y z) y)
          (else z)))
  ```

+ 1.5

  在应用序中，所有被传入的实际参数都会立即被求值，因此，在使用应用序的解释器里执行 `(test 0 (p))` 时，实际参数 `0` 和 `(p)` 都会被求值，而对 `(p)` 的求值将使解释器进入无限循环，因此，如果一个解释器在运行 Ben 的测试时陷入停滞，那么这个解释器使用的是应用序求值模式。

  另一方面，在正则序中，传入的实际参数只有在有需要时才会被求值，因此，在使用正则序的解释器里运行 `(test 0 (p))` 时， `0` 和 `(p)` 都不会立即被求值，当解释进行到 `if` 语句时，形式参数 `x` 的实际参数(也即是 `0`)会被求值(求值结果也是为 `0` )，然后和另一个 `0` 进行对比(`(= x 0)`)，因为对比的值为真(`#t`),所以 `if` 返回 `0` 作为值表达式的值，而这个值又作为 `test` 函数的值被返回。

  因为在正则序求值中，调用 `(p)` 从始到终都没有被执行，所以也就不会产生无限循环，因此，如果一个解释器在运行 Ben 的测试时顺利返回 `0` ，那么这个解释器使用的是正则序求值模式。

  > Note
  >
  >  
  >
  > 另一个需要说明的地方是『形式参数』和『实际参数』两个名词。
  >
  > 对于一个函数来说，它接受的参数的局部名被称为形式参数。
  >
  > 而调用函数时传入的表达式，被称为实际参数。
  >
  > 比如说，对于函数 `(define (square x) (* x x))` 来说， `x` 就是形式参数，当进行调用 `(square 2)` 时， `2` 就是形式参数 `x` 的实际参数。
  >
  > 当人们只说『参数』而不说明它是『形式参数』还是『实际参数』时，他们一般指的是『形式参数』，但是具体还是要看上下文来决定。

### 1.1.7 实例：采用牛顿法求平方根

+ 函数与过程的矛盾

  数学里，人们关心说明性的描述（是什么）

  计算机科学里，人们通常关心行动性描述（怎么做）

+ 牛顿迭代法

  ```lisp
  (define (average x y)
      (/ (+ x y) 2))
  
  (define (improve guess x)
      (average guess (/ x guess)))
  
  (define (square x)
      (* x x))
  
  (define (good-enough? guess x)
      (< (abs (- (square guess) x)) 0.001))
  
  (define (sqrt-iter guess x)
      (if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
  
  (define (sqrt x)
      (sqrt-iter 1.0 x))
  ```

### 练习

+ 1.6

  主要问题在于：`if` 语句是一种特殊形式，当它的 `predicate` 部分为真时， `then-clause` 分支会被求值，否则的话， `else-clause` 分支被求值，两个 `clause` 只有一个会被求值。

  而另一方面，新定义的 `new-if` 只是一个普通函数，它没有 `if` 所具有的特殊形式，根据解释器所使用的应用序求值规则，每个函数的实际参数在传入的时候都会被求值，因此，当使用 `new-if` 函数时，无论 `predicate` 是真还是假， `then-clause` 和 `else-clause` 两个分支都会被求值。

  [详解](https://sicp.readthedocs.io/en/latest/chp1/6.html)

+ 1.7

  改进`good-enough?`函数

  ```lisp
  (define (good-enough? guess x)
      (> 0.01
         (/ (abs (- guess x))
            x)))
  ```

+ 1.8

  ```lisp
  ```

  

